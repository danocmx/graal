package jdk.graal.compiler.lir.alloc.verifier;

import jdk.graal.compiler.core.common.LIRKind;
import jdk.graal.compiler.core.common.cfg.BasicBlock;
import jdk.graal.compiler.core.common.cfg.BlockMap;
import jdk.graal.compiler.debug.GraalError;
import jdk.graal.compiler.lir.ConstantValue;
import jdk.graal.compiler.lir.LIR;
import jdk.graal.compiler.lir.LIRInstruction;
import jdk.graal.compiler.lir.StandardOp;
import jdk.graal.compiler.lir.Variable;
import jdk.graal.compiler.lir.VirtualStackSlot;
import jdk.graal.compiler.lir.gen.LIRGenerationResult;
import jdk.graal.compiler.lir.phases.AllocationPhase;
import jdk.graal.compiler.options.Option;
import jdk.graal.compiler.options.OptionKey;
import jdk.graal.compiler.options.OptionType;
import jdk.vm.ci.code.RegisterValue;
import jdk.vm.ci.code.StackSlot;
import jdk.vm.ci.code.TargetDescription;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class RegisterAllocationVerifierPhase extends AllocationPhase {
    public static class Options {
        @Option(help = "Verify that register allocation is indeed, correct", type = OptionType.Debug)
        public static final OptionKey<Boolean> EnableRAVerifier = new OptionKey<>(false);
    }

    protected RAVerifierPreAllocPhase preallocPhaseRAVerifier;

    public AllocationPhase getPreAllocPhase() {
        this.preallocPhaseRAVerifier = new RAVerifierPreAllocPhase();
        return this.preallocPhaseRAVerifier;
    }

    @Override
    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
        assert this.preallocPhaseRAVerifier != null : "Phase before register allocation was not run, cannot verify it.";

        var instructions = this.getVerifierInstructions(lirGenRes.getLIR());
        var verifier = new RegisterAllocationVerifier(lirGenRes.getLIR(), instructions);
        if (!verifier.run()) {
            // TODO: every error generated by the verifier needs to be a lot more verbose.
            // throw new IllegalStateException("Could not verify the register allocation...");
            // Exception handler

            System.err.println("Verification failed - " + lirGenRes.getCompilationUnitName());
        }
    }

    /**
     * Create Register Verifier Instruction that was created by the Register Allocator.
     * Generally speaking, it's always a move instruction, other ones return null.
     *
     * @param instruction LIRInstruction newly created by Register Allocator
     * @return Spill, Reload, Move or null if instruction is not a move
     */
    protected RAVInstruction.Base getRAVMoveInstruction(LIRInstruction instruction) {
        if (!instruction.isValueMoveOp()) {
            if (instruction.isLoadConstantOp()) {
                var constatLoad = StandardOp.LoadConstantOp.asLoadConstantOp(instruction);
                var constant = constatLoad.getConstant();
                var result = (RegisterValue) constatLoad.getResult();

                // This isn't really a virtual move, but it currently acts the same, so we keep it,
                // we take constants as variables. TODO: maybe remove virtual move altogether for Move(reg, var/constant)
                return new RAVInstruction.VirtualMove(instruction, new ConstantValue(result.getValueKind(), constant), result);
            }

            return null;
        }
        var valueMov = StandardOp.ValueMoveOp.asValueMoveOp(instruction);

        var input = valueMov.getInput();
        var result = valueMov.getResult();

        if (input instanceof VirtualStackSlot stackSlot && result instanceof RegisterValue reg) {
            return new RAVInstruction.Reload(instruction, reg, stackSlot);
        } else if (result instanceof VirtualStackSlot stackSlot && input instanceof RegisterValue reg) {
            return new RAVInstruction.Spill(instruction, stackSlot, reg);
        } else if (input instanceof RegisterValue reg1 && result instanceof RegisterValue reg2) {
            return new RAVInstruction.Move(instruction, reg1, reg2);
        } else if (input instanceof StackSlot stackSlot && result instanceof RegisterValue reg) {
            return new RAVInstruction.Reload(instruction, reg, stackSlot);
        } else if (input instanceof RegisterValue reg && result instanceof StackSlot stackSlot) {
            return new RAVInstruction.Spill(instruction, stackSlot, reg);
        }

        return null;
    }

    protected BlockMap<List<RAVInstruction.Base>> getVerifierInstructions(LIR lir) {
        BlockMap<List<RAVInstruction.Base>> blockInstructions = new BlockMap<>(lir.getControlFlowGraph());
        var preallocMap = preallocPhaseRAVerifier.getPreallocMap();
        for (var blockId : lir.getBlocks()) {
            BasicBlock<?> block = lir.getBlockById(blockId);
            var instructionList = new LinkedList<RAVInstruction.Base>();

            ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);
            for (var instruction : instructions) {
                var rAVInstr = preallocMap.get(instruction);
                if (rAVInstr == null) {
                    var movOp = this.getRAVMoveInstruction(instruction);
                    if (movOp != null) {
                        instructionList.add(movOp);
                        continue;
                    }

                    throw new GraalError("Unknown instruction type for verification - " + instruction);
                }

                var opRAVInstr = (RAVInstruction.Op) rAVInstr;

                instruction.forEachInput(opRAVInstr.uses.copyCurrentProc);
                instruction.forEachOutput(opRAVInstr.dests.copyCurrentProc);
                instruction.forEachTemp(opRAVInstr.temp.copyCurrentProc);
                instruction.forEachAlive(opRAVInstr.alive.copyCurrentProc);

                // assert opRAVInstr.verifyContents();

                instructionList.add(opRAVInstr);
                var virtualMoves = opRAVInstr.getVirtualMoveList();
                instructionList.addAll(virtualMoves);
            }

            blockInstructions.put(block, instructionList);
        }
        return blockInstructions;
    }

    public static class RAVerifierPreAllocPhase extends AllocationPhase {
        protected Map<LIRInstruction, RAVInstruction.Base> preallocMap;

        protected RAVerifierPreAllocPhase() {
            this.preallocMap = new HashMap<>();
        }

        public Map<LIRInstruction, RAVInstruction.Base> getPreallocMap() {
            return preallocMap;
        }

        @Override
        protected void run(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
            LIR lir = lirGenRes.getLIR();
            for (var blockId : lir.getBlocks()) {
                BasicBlock<?> block = lir.getBlockById(blockId);
                ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);

                RAVInstruction.Base previousInstr = null;
                for (var instruction : instructions) {
                    if (this.isVirtualMove(instruction)) {
                        // Virtual moves (variable = MOV real register) are going to be removed by the allocator,
                        // but we still need the information about which variables are associated to which real
                        // registers, and so we store them. They are generally associated to other instructions
                        // that's why we append them here to the previous instruction (for example Label or Foreign Call)
                        // use these, if this instruction was deleted in the allocator, then they will be missing too.
                        assert previousInstr != null;

                        var valueMov = StandardOp.ValueMoveOp.asValueMoveOp(instruction);
                        var location = valueMov.getInput();
                        var variable = (Variable) valueMov.getResult();

                        var virtualMove = new RAVInstruction.VirtualMove(instruction, variable, location);
                        previousInstr.addVirtualMove(virtualMove);
                        continue; // No need to store virtual move here, it is stored into previous instruction.
                    }

                    var opRAVInstr = new RAVInstruction.Op(instruction);

                    instruction.forEachInput(opRAVInstr.uses.copyOriginalProc);
                    instruction.forEachOutput(opRAVInstr.dests.copyOriginalProc);
                    instruction.forEachTemp(opRAVInstr.temp.copyOriginalProc);
                    instruction.forEachAlive(opRAVInstr.alive.copyOriginalProc);

                    this.preallocMap.put(instruction, opRAVInstr);

                    previousInstr = opRAVInstr;
                }
            }
        }

        /**
         * Determines if instruction is a virtual move, a virtual move is
         * a move instruction that moves a real register value into a variable,
         * which is something that will always get removed from the final allocated
         * IR.
         *
         * @param instruction LIRInstruction we are looking at
         * @return true, if instruction is a virtual move, otherwise false
         */
        protected boolean isVirtualMove(LIRInstruction instruction) {
            if (!instruction.isValueMoveOp()) {
                return false;
            }

            var valueMov = StandardOp.ValueMoveOp.asValueMoveOp(instruction);
            var input = valueMov.getInput();
            return (input instanceof RegisterValue || input instanceof StackSlot) && valueMov.getResult() instanceof Variable;
        }
    }
}
